
'use strict';

const Express = require('express');
const Github = require('octop');
const Semver = require('semver');
const Promisify = require('es6-promisify');
const BodyParser = require('body-parser');
const Moo = require('./moo');

const debug = require('debug')('moo:service');
const app = Express();
const token = process.env.GITHUB_ACCESS_TOKEN;
const github = new Github({'token': token});

app.use(BodyParser.json());
app.post('/hook/github/push', function (req, res) {
  let currVersion;
  let currBackwards;
  let currBranch;
  let tags;
  const compares = [];
  const body = req.body;
  if (body.action !== 'synchronize') {
    return res.end();
  }
  const repo = github.getRepo(
    body.repository.owner.login, body.repository.name);

  debug('getting tags...');
  Promisify(repo.getTags)()
  .then(function (data) {
    tags = data;
    currBranch = body.pull_request.head.ref;

    debug('getting package.json')
    return Promisify(repo.read)(currBranch, 'package.json');
  })
  .then(function (data) {
    data = JSON.parse(data);
    currVersion = data.version;
    currBackwards = data.backwards;
    tags = refineTags(tags);
    
    debug('comparing tree...');
    console.log(tags);
    return compare(0);
  })
  .then(function (backwards) {
    res.end();
    let prog;
    const num = body.number;
    const text = 'current version: ' + currBackwards +', suggest use backwards: ' + backwards 
      + '\n> this message is generated by SeanBot';
    
    // check if current backwards equal to setup backwards value.
    if (currBackwards === backwards) {
      prog = Promisify(repo.removeLabel)(num, 'compatible');
    } else {
      prog = Promise.all([
        Promisify(repo.comment)(num, text),
        Promisify(repo.addLabels)(num, 'compatible')
      ]);
    }
    prog.then(function () {
      console.log('commented done');
    });
  })
  .catch(function (err) {
    if (err) {
      console.error(err && err.stack);
    }
    res.status(500).end(err);
  });

  function compare (i) {
    const tag = tags[i];
    return getMoo(tag.ref)
    .then(function (data) {
      compares[i] = {
        version: tag.version,
        value: JSON.stringify(data)
      };
      if (i === 0) return compare(1);
      // start to compare
      const currValue = compares[i].value;
      const lastValue = compares[i - 1].value;
      if (currValue === lastValue) {
        return compare(i + 1);
      } else {
        console.log('last version is', tag.version);
        return tag.version;
      }
    });
  }

  function getMoo (ref) {
    return Promisify(repo.getTree)(ref, true)
    .then(function (data) {
      return Promise.all(
        data.filter(function (item) { 
          return item && /^common\/models\/(.*)\.js$/.test(item.path); 
        }).map(function (item) {
          const read = Promisify(repo.read);
          return read(ref, item.path).then(Moo);
        })
      );
    });
  }

  function refineTags (tags) {
    return tags.map(function (item) {
      const m = /^refs\/tags\/v(.\..\..)$/.exec(item && item.ref);
      if (m && m[1]) {
        return { 
          ref: item.ref, 
          version: m[1] 
        };
      } else {
        return null;
      }
    }).filter(function (item) {
      return item && item.version && 
        Semver.valid(item.version) &&
        Semver.lt(item.version, currVersion);
    })
    .concat(
      {
        ref: currBranch,
        version: currVersion
      }
    )
    .reverse();
  }

});

if (process.env.NODE_ENV === 'test') {
  module.exports = app;
} else {
  const port = process.env.PORT || 8001;
  app.listen(port, function () {
    debug('Moo service is up on ' + port);
  });
}
